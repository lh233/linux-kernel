在阅读本节前请思考如下小问题。

- 在Linux2.4.x内核中，如何从一个page找到所有映射该页面的VMA？反向映射可以带来哪些便利？
- 阅读Linux4.0内核RMAP机制的代码，画出父子进程之间VMA、AVC、anon_vma和page等数据结构之间的关系图。
- 在Linux2.6.34中，RMAP机制采用了新的实现，在Linux2.6.33和之前的版本中称为旧版本RMAP机制。那么在旧版本RMAP机制中，如果父进程有1000个子进程，每个子进程都有一个VMA，这个VMA里面有1000个匿名页面，当所有的子进程的VMA同时发生写时复制时会是什么情况呢？

用户进程在使用虚拟内存过程中，从虚拟内存页面映射到物理内存页面，PTE页表项保留着这个记录，page数据结构中的_mapcount成员记录有多少个用户PTE页表项映射了物理页面。用户PTE页表项是指用户进程地址空间和物理页面建立映射的PTE页表项，不包括内核地址空间映射物理页面产生的PTE页表项。有的页面需要被迁移，有的页面长时间不使用需要被交换到磁盘。在交换之前，必须找出哪些进程使用这个页面，然后断开这些映射的PTE。一个物理页面可以同时被多个进程的虚拟内存映射，一个虚拟页面同时只能有一个物理页面与之映射。

在Linux2.4内核中，为了确定某一个页面是否被某个进程映射，必须遍历每个进程的页表，工作量相当大，效率很低。在Linux2.5开发期间，提出了反向映射（the object-basedreverse-mapping VM，RMAP)的概念。