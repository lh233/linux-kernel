父进程为自己的进程地址空间VMA分配物理内存时，通常会产生匿名页面。例如do_anonymous_page()会分配匿名页面，do_wp_page()发生写时复制COW时也会产生一个新的匿名页面。以do_anonymous_page()分配一个新的匿名页面为例：

```
[用户态ma11oc()分配内存->写入该内存->内核缺页中断->do_anonymous_page()]
static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
		unsigned long address, pte_t *page_table, pmd_t *pmd,
		unsigned int flags)
{
	...
	/* Allocate our own private page. */
	if (unlikely(anon_vma_prepare(vma)))
		goto oom;
	page = alloc_zeroed_user_highpage_movable(vma, address);
	if (!page)
		goto oom;
	...
	page_add_new_anon_rmap(page, vma, address);
	...
}
```

在分配匿名页面时，调用RMAP反向映射系统的两个API接口来完成初始化，一个是anon_vma_prepare()函数，另一个page_add_new_anon_rmap()函数。下面来看anon_vma_prepare()函数的实现：

```
do_anonymous_page()->anon_vma_prepare()
int anon_vma_prepare(struct vm_area_struct *vma)
{
	struct anon_vma *anon_vma = vma->anon_vma;
	struct anon_vma_chain *avc;

	might_sleep();
	if (unlikely(!anon_vma)) {
		struct mm_struct *mm = vma->vm_mm;
		struct anon_vma *allocated;

		avc = anon_vma_chain_alloc(GFP_KERNEL);
		if (!avc)
			goto out_enomem;

		anon_vma = find_mergeable_anon_vma(vma);
		allocated = NULL;
		if (!anon_vma) {
			anon_vma = anon_vma_alloc();
			if (unlikely(!anon_vma))
				goto out_enomem_free_avc;
			allocated = anon_vma;
		}

		anon_vma_lock_write(anon_vma);
		/* page_table_lock to protect against threads */
		spin_lock(&mm->page_table_lock);
		if (likely(!vma->anon_vma)) {
			vma->anon_vma = anon_vma;
			anon_vma_chain_link(vma, avc, anon_vma);
			/* vma reference or self-parent link for new root */
			anon_vma->degree++;
			allocated = NULL;
			avc = NULL;
		}
		spin_unlock(&mm->page_table_lock);
		anon_vma_unlock_write(anon_vma);

		if (unlikely(allocated))
			put_anon_vma(allocated);
		if (unlikely(avc))
			anon_vma_chain_free(avc);
	}
	return 0;

 out_enomem_free_avc:
	anon_vma_chain_free(avc);
 out_enomem:
	return -ENOMEM;
}
```

anon_vma_prepare()函数主要为进程地址空间VMA准备struct anon_vma数据结构和一些管理用的链表。RMAP反向映射系统中有两个重要的数据结构，一个是anon_vma，简称AV；另一个是anon_vma chain，简称AVC。struct anon_vma 数据结构定义如下：

```
struct anon_vma {
	struct anon_vma *root;		/* Root of this anon_vma tree */
	struct rw_semaphore rwsem;	/* W: modification, R: walking the list */
	/*
	 * The refcount is taken on an anon_vma when there is no
	 * guarantee that the vma of page tables will exist for
	 * the duration of the operation. A caller that takes
	 * the reference is responsible for clearing up the
	 * anon_vma if they are the last user on release
	 */
	atomic_t refcount;

	/*
	 * Count of child anon_vmas and VMAs which points to this anon_vma.
	 *
	 * This counter is used for making decision about reusing anon_vma
	 * instead of forking new one. See comments in function anon_vma_clone.
	 */
	unsigned degree;

	struct anon_vma *parent;	/* Parent of this anon_vma */

	/*
	 * NOTE: the LSB of the rb_root.rb_node is set by
	 * mm_take_all_locks() _after_ taking the above lock. So the
	 * rb_root must only be read/written after taking the above lock
	 * to be sure to see a valid next pointer. The LSB bit itself
	 * is serialized by a system wide lock only visible to
	 * mm_take_all_locks() (mm_all_locks_mutex).
	 */
	struct rb_root rb_root;	/* Interval tree of private "related" vmas */
};
```

- root：指向anon_vma数据结构中的根节点。
- rwsem：保护anon_vma中链表的读写信号量。
- refcount：引用计数。
- parent：指向父anon_vma数据结构。
- rb_root:红黑树根节点。anon_vma内部有一棵红黑树。

struct anon_vma_chain数据结构是连接父子进程中的枢纽，定义如下：

```
struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;   /* locked by mmap_sem & page_table_lock */
	struct rb_node rb;			/* locked by anon_vma->rwsem */
	unsigned long rb_subtree_last;
#ifdef CONFIG_DEBUG_VM_RB
	unsigned long cached_vma_start, cached_vma_last;
#endif
};
```

- vma:指向VMA，可以指向父进程的VMA，也可以指向子进程的VMA，具体情况需要具体分析。
- anon_vma：指向anon_vma数据结构，可以指向父进程的anon_vma数据结构，也可以指向子进程的anon_vma数据结构，具体情况需要具体分析。
- same_vma：链表节点，通常把anon_vma chain 添加到vma->anon _vma_chain链表中。
- rb：红黑树节点，通常把anon_vma_chain添加到anon_vma->rb_root的红黑树中。

回到anon_vma_prepare()函数中。