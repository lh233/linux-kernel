KSM在初始化时会创建一个名为“ksmd”的内核线程。

```
[mm/ksm.c]

static int __init ksm_init(void)
{
	struct task_struct *ksm_thread;
	int err;

	err = ksm_slab_init();
	if (err)
		goto out;

	ksm_thread = kthread_run(ksm_scan_thread, NULL, "ksmd");
	if (IS_ERR(ksm_thread)) {
		pr_err("ksm: creating kthread failed\n");
		err = PTR_ERR(ksm_thread);
		goto out_free;
	}

#ifdef CONFIG_SYSFS
	err = sysfs_create_group(mm_kobj, &ksm_attr_group);
	if (err) {
		pr_err("ksm: register sysfs failed\n");
		kthread_stop(ksm_thread);
		goto out_free;
	}
#else
	ksm_run = KSM_RUN_MERGE;	/* no way for user to start it */

#endif /* CONFIG_SYSFS */

#ifdef CONFIG_MEMORY_HOTREMOVE
	/* There is no significance to this priority 100 */
	hotplug_memory_notifier(ksm_memory_callback, 100);
#endif
	return 0;

out_free:
	ksm_slab_free();
out:
	return err;
}
```

KSM只会处理通过madvise系统调用显式指定的用户进程空间内存，因此用户程序想使用这个功能就必须在分配内存时显式地调用“madvise(addr,length,MADV_MERGEABLE)”，如果用户想在KSM中取消某一个用户进程地址空间的合并功能，也需要显式地用“madvise(addr,length,MADV_UNMERGEABLE)"。

在Android系统中，在libc库（Android系统的libc库是bionic)中的mmap函数实现已经默认添加了此功能。

```
static bool kernel has MADV_MERGEABLE=true;
void* mmap64(void* addr,sizet size,int prot,int flags,int fd,off64_t offset){
	bool is private anonymous=(flags & (MAP_PRIVATE |MAP_ANONYMOUS))!=0; 
	void* result=mmap2(addr,size,prot,flags,fd,offset >>MMAP2_SHIFT); 
	if(result!=MAP FAILED && kernel has MADV MERGEABLE && is_private_anonymous
	{
		int rc =madvise(result,size,MADV_ MERGEABLE); 
		if (rc==-1 && errno==EINVAL){ 
			kernel_has_MADV_MERGEABLE=false;
		}
	}
    return result;
}
void* mmap(void* addr,size t size,int prot,int flags,int fd,off_t offset){
	return mmap64(addr,size,prot,flags,fd,static_cast<off64_t>((unsigned 1ong)offset));
}
    
```

