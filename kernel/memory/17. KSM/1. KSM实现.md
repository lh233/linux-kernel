KSM在初始化时会创建一个名为“ksmd”的内核线程。

```
[mm/ksm.c]

static int __init ksm_init(void)
{
	struct task_struct *ksm_thread;
	int err;

	err = ksm_slab_init();
	if (err)
		goto out;

	ksm_thread = kthread_run(ksm_scan_thread, NULL, "ksmd");
	if (IS_ERR(ksm_thread)) {
		pr_err("ksm: creating kthread failed\n");
		err = PTR_ERR(ksm_thread);
		goto out_free;
	}

#ifdef CONFIG_SYSFS
	err = sysfs_create_group(mm_kobj, &ksm_attr_group);
	if (err) {
		pr_err("ksm: register sysfs failed\n");
		kthread_stop(ksm_thread);
		goto out_free;
	}
#else
	ksm_run = KSM_RUN_MERGE;	/* no way for user to start it */

#endif /* CONFIG_SYSFS */

#ifdef CONFIG_MEMORY_HOTREMOVE
	/* There is no significance to this priority 100 */
	hotplug_memory_notifier(ksm_memory_callback, 100);
#endif
	return 0;

out_free:
	ksm_slab_free();
out:
	return err;
}
```

KSM只会处理通过madvise系统调用显式指定的用户进程空间内存，因此用户程序想使用这个功能就必须在分配内存时显式地调用“madvise(addr,length,MADV_MERGEABLE)”，如果用户想在KSM中取消某一个用户进程地址空间的合并功能，也需要显式地用“madvise(addr,length,MADV_UNMERGEABLE)"。

在Android系统中，在libc库（Android系统的libc库是bionic)中的mmap函数实现已经默认添加了此功能。