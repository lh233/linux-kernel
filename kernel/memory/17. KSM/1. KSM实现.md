KSM在初始化时会创建一个名为“ksmd”的内核线程。

```
[mm/ksm.c]

static int __init ksm_init(void)
{
	struct task_struct *ksm_thread;
	int err;

	err = ksm_slab_init();
	if (err)
		goto out;

	ksm_thread = kthread_run(ksm_scan_thread, NULL, "ksmd");
	if (IS_ERR(ksm_thread)) {
		pr_err("ksm: creating kthread failed\n");
		err = PTR_ERR(ksm_thread);
		goto out_free;
	}

#ifdef CONFIG_SYSFS
	err = sysfs_create_group(mm_kobj, &ksm_attr_group);
	if (err) {
		pr_err("ksm: register sysfs failed\n");
		kthread_stop(ksm_thread);
		goto out_free;
	}
#else
	ksm_run = KSM_RUN_MERGE;	/* no way for user to start it */

#endif /* CONFIG_SYSFS */

#ifdef CONFIG_MEMORY_HOTREMOVE
	/* There is no significance to this priority 100 */
	hotplug_memory_notifier(ksm_memory_callback, 100);
#endif
	return 0;

out_free:
	ksm_slab_free();
out:
	return err;
}
```

KSM只会处理通过madvise系统调用显式指定的用户进程空间内存，因此用户程序想使用这个功能就必须在分配内存时显式地调用“madvise(addr,length,MADV_MERGEABLE)”，如果用户想在KSM中取消某一个用户进程地址空间的合并功能，也需要显式地用“madvise(addr,length,MADV_UNMERGEABLE)"。

在Android系统中，在libc库（Android系统的libc库是bionic)中的mmap函数实现已经默认添加了此功能。

```
static bool kernel has MADV_MERGEABLE=true;
void* mmap64(void* addr,sizet size,int prot,int flags,int fd,off64_t offset){
	bool is private anonymous=(flags & (MAP_PRIVATE |MAP_ANONYMOUS))!=0; 
	void* result=mmap2(addr,size,prot,flags,fd,offset >>MMAP2_SHIFT); 
	if(result!=MAP FAILED && kernel has MADV MERGEABLE && is_private_anonymous
	{
		int rc =madvise(result,size,MADV_ MERGEABLE); 
		if (rc==-1 && errno==EINVAL){ 
			kernel_has_MADV_MERGEABLE=false;
		}
	}
    return result;
}
void* mmap(void* addr,size t size,int prot,int flags,int fd,off_t offset){
	return mmap64(addr,size,prot,flags,fd,static_cast<off64_t>((unsigned 1ong)offset));
}
    
```

第5-11行，判断mmap分配的内存，即进程用户空间地址是否私有映射（MAP_PRIVATE）或者匿名映射（MAP_ANONYMOUS），如果是，则显式调用madivese系统把进程用户空间地址区间添加到Linux内核KSM系统中。

```
int __ksm_enter(struct mm_struct *mm)
{
	struct mm_slot *mm_slot;
	int needs_wakeup;

	mm_slot = alloc_mm_slot();
	if (!mm_slot)
		return -ENOMEM;

	/* Check ksm_run too?  Would need tighter locking */
	needs_wakeup = list_empty(&ksm_mm_head.mm_list);

	spin_lock(&ksm_mmlist_lock);
	insert_to_mm_slots_hash(mm, mm_slot);
	/*
	 * When KSM_RUN_MERGE (or KSM_RUN_STOP),
	 * insert just behind the scanning cursor, to let the area settle
	 * down a little; when fork is followed by immediate exec, we don't
	 * want ksmd to waste time setting up and tearing down an rmap_list.
	 *
	 * But when KSM_RUN_UNMERGE, it's important to insert ahead of its
	 * scanning cursor, otherwise KSM pages in newly forked mms will be
	 * missed: then we might as well insert at the end of the list.
	 */
	if (ksm_run & KSM_RUN_UNMERGE)
		list_add_tail(&mm_slot->mm_list, &ksm_mm_head.mm_list);
	else
		list_add_tail(&mm_slot->mm_list, &ksm_scan.mm_slot->mm_list);
	spin_unlock(&ksm_mmlist_lock);

	set_bit(MMF_VM_MERGEABLE, &mm->flags);
	atomic_inc(&mm->mm_count);

	if (needs_wakeup)
		wake_up_interruptible(&ksm_thread_wait);

	return 0;
}
```

第6行代码,分配一个 struct mm_slot数据结构。

第13行代码,添加管理 ksm_mmlist链表的 spinlock锁

第14行代码,把当前的mm数据结构添加到mm_slots_hash哈希表中。

第25-28行代码,把 mm slot添加到 ksm_scan_mm slot-> mm_list链表中。

第31行代码,设置mm->fags中的 MMF_VM_MERGEABLE标志位,表示这个进程已经添加到KSM系统中。

第34~35行代码,如果之前 ksm_mm_head.mm_list链表为空,则唤醒ksmd内核线程。

```
[ksmd内核线程]
static int ksm_scan_thread(void *nothing)
{
	set_freezable();
	set_user_nice(current, 5);

	while (!kthread_should_stop()) {
		mutex_lock(&ksm_thread_mutex);
		wait_while_offlining();
		if (ksmd_should_run())
			ksm_do_scan(ksm_thread_pages_to_scan);
		mutex_unlock(&ksm_thread_mutex);

		try_to_freeze();

		if (ksmd_should_run()) {
			schedule_timeout_interruptible(
				msecs_to_jiffies(ksm_thread_sleep_millisecs));
		} else {
			wait_event_freezable(ksm_thread_wait,
				ksmd_should_run() || kthread_should_stop());
		}
	}
	return 0;
}
```

ksm_scan_thread是ksmd内核线程的主干,每次会执行 ksm_do_scan()函数去扫描和合并100个页面(见 ksm_thread_pages_to_scan变量),然后睡眠等待20毫秒(见 ksm_thread_sleepmillisecs变量),这两个参数可以在“/ sys/kernel/mm/ksm”目录下的相关参数中去设置和修改。

```
[ksmd内核线程]
static void ksm_do_scan(unsigned int scan_npages)
{
	struct rmap_item *rmap_item;
	struct page *uninitialized_var(page);

	while (scan_npages-- && likely(!freezing(current))) {
		cond_resched();
		rmap_item = scan_get_next_rmap_item(&page);
		if (!rmap_item)
			return;
		cmp_and_merge_page(page, rmap_item);
		put_page(page);
	}
}
```

ksm_do_scan()函数在 while循环中尝试去合并 scan_npages个页面, scan_get_next_rmap_item()获取一个合适的匿名页面page, cmp_and_merge_page()会让page 在在KSM中的stable和unstable 两棵红黑树中查找是否有合适合并的对象,并且尝试去合并它们。下面首先来看KSM的核心数据结构。

```
[mm/ksm.c]
struct rmap_item {
	struct rmap_item *rmap_list;
	union {
		struct anon_vma *anon_vma;	/* when stable */
#ifdef CONFIG_NUMA
		int nid;		/* when node of unstable tree */
#endif
	};
	struct mm_struct *mm;
	unsigned long address;		/* + low bits used for flags below */
	unsigned int oldchecksum;	/* when unstable */
	union {
		struct rb_node node;	/* when node of unstable tree */
		struct {		/* when listed from stable tree */
			struct stable_node *head;
			struct hlist_node hlist;
		};
	};
};

struct mm_slot {
	struct hlist_node link;
	struct list_head mm_list;
	struct rmap_item *rmap_list;
	struct mm_struct *mm;
};

struct ksm_scan {
	struct mm_slot *mm_slot;
	unsigned long address;
	struct rmap_item **rmap_list;
	unsigned long seqnr;
};
```

rmap_item 数据结构描述一个虚拟地址反向映射的条目(item)。

- rmap_list:所有的rmap_item连接成一个链表,链表头在ksm_scan.rmap_list中。
- anon_vma:当rmap_item加入stable树时，指向VMA的anon_vma数据结构。
- mm:进程的struct mm_struct数据结构。
- address: rmap_item所跟踪的用户空间地址，
- oldchecksum:虚拟地址对应的物理页面的旧校验值。
- node: rmap_item加入unstable红黑树的节点。
- head:加入stable红黑树的节点。
- hlist: stable链表。

mmslot数据结构描述添加到KSM系统中将要被扫描的进程mm struct数据结构。

- link:用于添加到mm_slot哈希表中。
- mm_list:用于添加到mm_slot链表中，银链表头在ksm_mm_head。
- rmap_list: rmap_item链表头。
- mm:进程的mm数据结构。

ksm_scan数据结构用于表示当前扫描的状态。

- mm_slot:当前正在扫描的mm_slot。
- address:下一次扫描地址。
- rmap_list:将要扫描rmap_item的指针。
- seqnr:全部扫描完成后会计数一次，用于删除 unstable节点。
