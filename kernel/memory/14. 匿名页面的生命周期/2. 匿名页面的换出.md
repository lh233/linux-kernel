假设现在系统内存紧张,需要回收一些页面来释放内存。 anon_page刚分配时会加入活跃LRU链表( LRU_ACTIVE_ANON)的头部,在经历了活跃LRU链表的一段时间的移动,该 anon_page到达活跃LRU链表的尾部, shrink_active_list()函数把该页加入不活跃LRU链表( LRU_INACTIVE_ANON)。

shrink_inactive_list()函数扫描不活跃链表。

（1）第一次扫描不活跃链表时，shrink_inactive_list()->add_to_swap()函数会为该页分配swap分区空间；

此时匿名页面的_count、__mapcount和flags状态如下：

```
page->_count=3（该引用计数增加的地方：1.分配页面；2.分离页面；3.add_to swap()）
page->_mapcount=0
page->flags = [PG_lru| PG_swapbacked | PG_swapcache | PG_dirty | PG_uptodate | PG_locked ]
```

为什么add_to_swap()之后page->_count变成了3呢？因为在分离LRU链表时该引用计数加1了，另外add_to_swap()本身也会让该引用计数加1。