Linux为页面迁移提供了一个系统调用migrate_pages，最早是在Linux2.6.16版本加入的，它可以迁移一个进程的所有页面到指定内存节点上。该系统调用在用户空间的函数接口如下：

```
#include <numaif.h>
long migrate_page(struct address_space *,
			struct page *, struct page *, enum migrate_mode);
```

该系统调用最早是为了在NUMA系统上提供一种能迁移进程到任意内存节点的能力。现在内核除了为NUMA系统提供页迁移能力外，其他的一些模块也可以利用页迁移功能做一些事情，例如内存规整和内存热插拔等。

**migrate_pages()函数**

```
//migrate_pages()函数的参数from表示将要迁移的页面链表，get_new_page是内存函数指针，put_new_page是迁移失败时释放目标页面的函数指针，private 是传递给get_new_page的参数，mode是迁移模式，reason表示迁移原因。
int migrate_pages(struct list_head *from, new_page_t get_new_page,
		free_page_t put_new_page, unsigned long private,
		enum migrate_mode mode, int reason)
{
	int retry = 1;
	int nr_failed = 0;
	int nr_succeeded = 0;
	int pass = 0;
	struct page *page;
	struct page *page2;
	int swapwrite = current->flags & PF_SWAPWRITE;
	int rc;

	if (!swapwrite)
		current->flags |= PF_SWAPWRITE;
	
	//for循环表示这里会尝试10次，从from链表摘取一个页面，然后调用unmap_and_move()函数进行页的迁移，返回MIGRATEPAGE_SUCCESS表示页迁移成功
	for(pass = 0; pass < 10 && retry; pass++) {
		retry = 0;

		list_for_each_entry_safe(page, page2, from, lru) {
			cond_resched();

			if (PageHuge(page))
				rc = unmap_and_move_huge_page(get_new_page,
						put_new_page, private, page,
						pass > 2, mode);
			else
				rc = unmap_and_move(get_new_page, put_new_page,
						private, page, pass > 2, mode);

			switch(rc) {
			case -ENOMEM:
				goto out;
			case -EAGAIN:
				retry++;
				break;
			case MIGRATEPAGE_SUCCESS:
				nr_succeeded++;
				break;
			default:
				/*
				 * Permanent failure (-EBUSY, -ENOSYS, etc.):
				 * unlike -EAGAIN case, the failed page is
				 * removed from migration page list and not
				 * retried in the next outer loop.
				 */
				nr_failed++;
				break;
			}
		}
	}
	rc = nr_failed + retry;
out:
	if (nr_succeeded)
		count_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);
	if (nr_failed)
		count_vm_events(PGMIGRATE_FAIL, nr_failed);
	trace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);

	if (!swapwrite)
		current->flags &= ~PF_SWAPWRITE;

	return rc;
}
```



```
[migrate_pages()->unmap_and_move()]
static int unmap_and_move(new_page_t get_new_page, free_page_t put_new_page,
			unsigned long private, struct page *page, int force,
			enum migrate_mode mode)
{
	int rc = 0;
	int *result = NULL;
	
	//调用get_new_page()分配一个新的页面newpage，接下来调用__unmap_and_move()去尝试迁移页面page到新分配的页面newpage中。
	struct page *newpage = get_new_page(page, private, &result);

	if (!newpage)
		return -ENOMEM;

	if (page_count(page) == 1) {
		/* page was freed from under us. So we are done. */
		goto out;
	}

	if (unlikely(PageTransHuge(page)))
		if (unlikely(split_huge_page(page)))
			goto out;

	rc = __unmap_and_move(page, newpage, force, mode);

out:
	//返回-EAGAIN表示页迁移失败，会把这个页面重新放回LRU链表中。如果页迁移不成功，那么会把新分配的页面释放。
	if (rc != -EAGAIN) {
		/*
		 * A page that has been migrated has all references
		 * removed and will be freed. A page that has not been
		 * migrated will have kepts its references and be
		 * restored.
		 */
		list_del(&page->lru);
		dec_zone_page_state(page, NR_ISOLATED_ANON +
				page_is_file_cache(page));
		putback_lru_page(page);
	}

	/*
	 * If migration was not successful and there's a freeing callback, use
	 * it.  Otherwise, putback_lru_page() will drop the reference grabbed
	 * during isolation.
	 */
	if (rc != MIGRATEPAGE_SUCCESS && put_new_page) {
		ClearPageSwapBacked(newpage);
		put_new_page(newpage, private);
	} else if (unlikely(__is_movable_balloon_page(newpage))) {
		/* drop our reference, page already in the balloon */
		put_page(newpage);
	} else
		//表示迁移成功，新分配的页也会加入到LRU链表中
		putback_lru_page(newpage);

	if (result) {
		if (rc)
			*result = rc;
		else
			*result = page_to_nid(newpage);
	}
	return rc;
}
```

具体实现页的迁移是在__unmap_and_move()函数中，返回MIGRATEPAGE_SUCCESS表示迁移成功。



