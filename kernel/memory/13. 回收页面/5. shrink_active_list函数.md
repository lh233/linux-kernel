首先来看当不活跃LRU的页面数量少于活跃LRU的页面数量的情况，shrink_active_list()函数扫描活跃LRU链表，看是否有页面可以迁移到不活跃LRU链表中。

```
[kswapd()->balance_pgdat()->kswapd_shrink_zone()->shrink_zone()->shrink_1ruvec()->shrink_active_list()]
static void shrink_active_list(unsigned long nr_to_scan,
			       struct lruvec *lruvec,
			       struct scan_control *sc,
			       enum lru_list lru)
{
	unsigned long nr_taken;
	unsigned long nr_scanned;
	unsigned long vm_flags;
	
	//这里定义了3个临时链表l_hold、l_active和l_inactive。在操作LRU链表时，有一把保护LRU的spinlock锁zone->lru_lock。isolate_lru_pages()批量地把LRU链表的部分页面先迁移到临时链表中，从而减少加锁的时间。
	LIST_HEAD(l_hold);	/* The pages which were snipped off */
	LIST_HEAD(l_active);
	LIST_HEAD(l_inactive);
	struct page *page;
	struct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;
	unsigned long nr_rotated = 0;
	isolate_mode_t isolate_mode = 0;
	int file = is_file_lru(lru);
	//从 lruvec 结构返回zone数据结构。
	struct zone *zone = lruvec_zone(lruvec);

	lru_add_drain();

	if (!sc->may_unmap)
		isolate_mode |= ISOLATE_UNMAPPED;
	if (!sc->may_writepage)
		isolate_mode |= ISOLATE_CLEAN;
	//申请zone->lru_lock锁来保护LRU链表操作。
	spin_lock_irq(&zone->lru_lock);

	//isolate_lru_pages()批量地从LRU链表中分离nr_to_scan个页面到l_hold链表中，这里会根据isolate_mode来考虑一些特殊情况，基本上就是把LRU链表的页面迁移到临时l_hold链表中。
	nr_taken = isolate_lru_pages(nr_to_scan, lruvec, &l_hold,
				     &nr_scanned, sc, isolate_mode, lru);
	if (global_reclaim(sc))
		//增加zone中的NR_PAGES_SCANNED计数。
		__mod_zone_page_state(zone, NR_PAGES_SCANNED, nr_scanned);

	//增加recent_scanned[]计数，在get_scan_count()计算匿名页面和文件缓存页面分别扫描数量时会用到。
	reclaim_stat->recent_scanned[file] += nr_taken;

	//增加zone中PGREFILL、NR_LRU_BASE和NR_ISOLATED_ANON计数。
	__count_zone_vm_events(PGREFILL, zone, nr_scanned);
	__mod_zone_page_state(zone, NR_LRU_BASE + lru, -nr_taken);
	__mod_zone_page_state(zone, NR_ISOLATED_ANON + file, nr_taken);
	spin_unlock_irq(&zone->lru_lock);

	//扫描临时l_hold链表中的页面，有些页面会添加到l_active中，有些会加入到l_inactive中。
	while (!list_empty(&l_hold)) {
		cond_resched();
		page = lru_to_page(&l_hold);
		list_del(&page->lru);

		//如果页面是不可回收的，那么就把它返回到不可回收的LRU链表上去
		if (unlikely(!page_evictable(page))) {
			putback_lru_page(page);
			continue;
		}

		if (unlikely(buffer_heads_over_limit)) {
			if (page_has_private(page) && trylock_page(page)) {
				if (page_has_private(page))
					try_to_release_page(page, 0);
				unlock_page(page);
			}
		}
		
		
		//page_referenced()函数返回该页最近访问引用pte的个数，返回0表示最近没有被访问过。除了可执行的page cache页面，其他被访问的引用的页面（referenced page）为什么都被加入到不活跃链表里，而不是继续待在活跃的LRU链表中。
		//把最近访问引用的页面全部迁移到活跃的LRU链表会产生一个比较大的可扩展性问题
		if (page_referenced(page, 0, sc->target_mem_cgroup,
				    &vm_flags)) {
			nr_rotated += hpage_nr_pages(page);
			/*
			 * Identify referenced, file-backed active pages and
			 * give them one more trip around the active list. So
			 * that executable code get better chances to stay in
			 * memory under moderate memory pressure.  Anon pages
			 * are not likely to be evicted by use-once streaming
			 * IO, plus JVM can create lots of anon VM_EXEC pages,
			 * so we ignore them here.
			 */
			if ((vm_flags & VM_EXEC) && page_is_file_cache(page)) {
				list_add(&page->lru, &l_active);
				continue;
			}
		}

		ClearPageActive(page);	/* we are de-activating */
		list_add(&page->lru, &l_inactive);
	}

	/*
	 * Move pages back to the lru list.
	 */
	spin_lock_irq(&zone->lru_lock);
	/*
	 * Count referenced pages from currently used mappings as rotated,
	 * even though only some of them are actually re-activated.  This
	 * helps balance scan pressure between file and anonymous pages in
	 * get_scan_count.
	 */
	reclaim_stat->recent_rotated[file] += nr_rotated;

	move_active_pages_to_lru(lruvec, &l_active, &l_hold, lru);
	move_active_pages_to_lru(lruvec, &l_inactive, &l_hold, lru - LRU_ACTIVE);
	__mod_zone_page_state(zone, NR_ISOLATED_ANON + file, -nr_taken);
	spin_unlock_irq(&zone->lru_lock);

	mem_cgroup_uncharge_list(&l_hold);
	free_hot_cold_page_list(&l_hold, true);
}
```

