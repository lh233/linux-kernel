balance_pgdat 函数是回收页面的主函数。这个函数比较长，首先看一个框架，主体函数是一个很长的while循环，简化后的代码如下：

```
[balance_pgdat()函数总体框架]
static unsigned long balance_pgdat(pg_data_t *pgdat, int order,
							int *classzone_idx)
{
	struct scan_control sc = {
		.gfp_mask = GFP_KERNEL,
		.order = order,
		.priority = DEF_PRIORITY,
		.may_writepage = !laptop_mode,
		.may_unmap = 1,
		.may_swap = 1,
	};
	...
	do {
		//从高端zone往低端zone方向查找第一个处于不平衡的end_zone
		for (i = pgdat->nr_zones - 1; i >= 0; i--) {
			struct zone *zone = pgdat->node_zones + i;
			...
			if (!zone_balanced(zone, order, 0, 0)) {
				end_zone = i;
				break;
			}
		}
		
		//从最低端zone开始页面回收，一直到end_zone
		for (i = 0; i <= end_zone; i++) {
			struct zone *zone = pgdat->node_zones + i;
			kswapd_shrink_zone(zone, end_zone,
					       &sc, &nr_attempted);
		}
		//不断加大扫码粒度，并且检查最低端zone到classzone_idx的zone是否处于平衡状态
	}while (sc.priority >= 1 &&
		 !pgdat_balanced(pgdat, order, *classzone_idx));
}
```

struct scan_control数据结构用于控制页面回收的参数，例如要回收页面的个数nr_to_reclaim、分配掩码gfpmask、分配的阶数order（2order个页面）、扫描LRU链表的优先级priority等。priority成员表示扫描的优先级，用于计算每次扫描页面的数量，计算方法是total_size>>priority，初始值为12，依次递减。priority数值越低，扫描的页面数量越大，相当于逐步加大扫描粒度。struct_scan_control数据结构定义在mm/vmscan.c文件中。

```
[mm/vmscan.c]
struct scan_control {
	/* How many pages shrink_list() should reclaim */
	unsigned long nr_to_reclaim;

	/* This context's GFP mask */
	gfp_t gfp_mask;

	/* Allocation order */
	int order;

	/*
	 * Nodemask of nodes allowed by the caller. If NULL, all nodes
	 * are scanned.
	 */
	nodemask_t	*nodemask;

	/*
	 * The memory cgroup that hit its limit and as a result is the
	 * primary target of this reclaim invocation.
	 */
	struct mem_cgroup *target_mem_cgroup;

	/* Scan (total_size >> priority) pages at once */
	int priority;

	unsigned int may_writepage:1;

	/* Can mapped pages be reclaimed? */
	unsigned int may_unmap:1;

	/* Can pages be swapped as part of reclaim? */
	unsigned int may_swap:1;

	/* Can cgroups be reclaimed below their normal consumption range? */
	unsigned int may_thrash:1;

	unsigned int hibernation_mode:1;

	/* One of the zones is ready for compaction */
	unsigned int compaction_ready:1;

	/* Incremented by the number of inactive pages that were scanned */
	unsigned long nr_scanned;

	/* Number of pages freed so far during a call to shrink_zones() */
	unsigned long nr_reclaimed;
};
```

pgdat_balanced()需要注意参数classzone_idx，它表示在页面分配路径上计算出来第一个最合适内存分配的zone的编号，通过wake_all_kswapds()传递下来。

```
static bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)
{
	unsigned long managed_pages = 0;
	unsigned long balanced_pages = 0;
	int i;

	/* Check the watermark levels */
	//遍历从最低端的zone到classzone_idx的页面是否处于平衡
	for (i = 0; i <= classzone_idx; i++) {
		struct zone *zone = pgdat->node_zones + i;

		if (!populated_zone(zone))
			continue;

		managed_pages += zone->managed_pages;

		/*
		 * A special case here:
		 *
		 * balance_pgdat() skips over all_unreclaimable after
		 * DEF_PRIORITY. Effectively, it considers them balanced so
		 * they must be considered balanced here as well!
		 */
		if (!zone_reclaimable(zone)) {
			balanced_pages += zone->managed_pages;
			continue;
		}

		if (zone_balanced(zone, order, 0, i))
			balanced_pages += zone->managed_pages;
		else if (!order)
			return false;
	}

	if (order)
		return balanced_pages >= (managed_pages >> 2);
	else
		return true;
}
```

注意参数classzone_idx是由页面分配路径上传递过来的。pgdat_balanced()判断一个内存节点上的物理页面是否处于平衡状态，返回true，则表示该内存节点处于平衡状态。注意第7行代码，遍历从最低端的zone到classzone_idx的页面是否处于平衡状态。

对于order为0的情况，所有的zone都是平衡的。对于order大于0的内存分配，需要统计从最低端zone到classzone_idx zone中所有处于平衡状态zone的页面数量（balanced_pages），当大于这个节点的所有管理的页面managed_pages的25%，那么就认为这个内存节点已处于平衡状态。如果这个zone的空闲页面高于WMARK_HIGH水位，那么这个zone所有管理的页面可以看作balanced pages。zone_balanced()函数用于判断zone的空闲页面是否处于WMARK_HIGH水位之上，返回true，则表示zone处于WMARK_HIGH之上。

```
[pgdat_balanced()->zone_balanced()]
static bool zone_balanced(struct zone *zone, int order,
			  unsigned long balance_gap, int classzone_idx)
{
	if (!zone_watermark_ok_safe(zone, order, high_wmark_pages(zone) +
				    balance_gap, classzone_idx, 0))
		return false;

	if (IS_ENABLED(CONFIG_COMPACTION) && order && compaction_suitable(zone,
				order, 0, classzone_idx) == COMPACT_SKIPPED)
		return false;

	return true;
}

bool zone_watermark_ok_safe(struct zone *z, unsigned int order,
			unsigned long mark, int classzone_idx, int alloc_flags)
{
	long free_pages = zone_page_state(z, NR_FREE_PAGES);

	if (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)
		free_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);

	return __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,
								free_pages);
}
```

页面分配路径page allocator和页面回收路径kswapd之间有很多交互的地方，如图2.28所示，总结如下。

![页面分配路径和页面回收路径](picture/页面分配路径和页面回收路径.png)

- 当页面分配路径page allocator 在低水位中分配内存失败时，会唤醒kswapd内核线程，把order和preferred_zone传递给kswapd，这两个参数是它们之间联系的纽带。
- 页面分配路径page allocator 和页面回收路径kswapd在扫描zone时的方向是相反的，页面分配路径page allocator 从ZONE_HIGHMEM往ZONE_NORMAL方向扫描zone，kswapd则相反。
- 如何判断kswapd应该停止页面回收呢?一个重要的条件是从zone_normal到preferred_zone处于平衡状态时，那么就认为这个内存节点处于平衡状态，可以停止页面回收。
- 页面分配路径page allocator和页面回收路径kswapd采用zone的水位标不同，pagealocator 采用低水位，即在低水位中无法分配内存，就唤醒kswapd；而kswapd判断是否停止页面回收采用的高水位。这两个标准的差别会导致一些问题，例如一个内存节点zone之间页面的老化速度不一致，为此内核提供了很多诡异的补丁，在后续章节会继续探讨。

上述内容是从整体角度来观察balance_pgdat()函数的实现框架，下面继续深入探讨该函数。

```
[kswapd()->balance_pgdat()]
static unsigned long balance_pgdat(pg_data_t *pgdat, int order,
							int *classzone_idx)
{
	int i;
	int end_zone = 0;	/* Inclusive.  0 = ZONE_DMA */
	unsigned long nr_soft_reclaimed;
	unsigned long nr_soft_scanned;
	struct scan_control sc = {
		.gfp_mask = GFP_KERNEL,
		.order = order,
		.priority = DEF_PRIORITY,
		.may_writepage = !laptop_mode,
		.may_unmap = 1,
		.may_swap = 1,
	};
	count_vm_event(PAGEOUTRUN);

	do {
		unsigned long nr_attempted = 0;
		bool raise_priority = true;
		bool pgdat_needs_compaction = (order > 0);

		sc.nr_reclaimed = 0;

		/*
		 * Scan in the highmem->dma direction for the highest
		 * zone which needs scanning
		 */
		 //从ZONE_HIGHEM->ZONE_NORMAL的方向对zone进行扫描，直到找出第一个不平衡的zone，即水位处于WMARK_HIGH之下的zone为止。
		for (i = pgdat->nr_zones - 1; i >= 0; i--) {
			struct zone *zone = pgdat->node_zones + i;

			if (!populated_zone(zone))
				continue;

			if (sc.priority != DEF_PRIORITY &&
			    !zone_reclaimable(zone))
				continue;

			/*
			 * Do some background aging of the anon list, to give
			 * pages a chance to be referenced before reclaiming.
			 */
			age_active_anon(zone, &sc);

			/*
			 * If the number of buffer_heads in the machine
			 * exceeds the maximum allowed level and this node
			 * has a highmem zone, force kswapd to reclaim from
			 * it to relieve lowmem pressure.
			 */
			if (buffer_heads_over_limit && is_highmem_idx(i)) {
				end_zone = i;
				break;
			}
			//同样使用zone_balanced()函数来计算zone是否处于WMARK_HIGH水位之上，找到之后保存到end_zone变量中。
			if (!zone_balanced(zone, order, 0, 0)) {
				end_zone = i;
				break;
			} else {
				/*
				 * If balanced, clear the dirty and congested
				 * flags
				 */
				clear_bit(ZONE_CONGESTED, &zone->flags);
				clear_bit(ZONE_DIRTY, &zone->flags);
			}
		}

		if (i < 0)
			goto out;
			
		for (i = 0; i <= end_zone; i++) {
			struct zone *zone = pgdat->node_zones + i;

			if (!populated_zone(zone))
				continue;

			/*
			 * If any zone is currently balanced then kswapd will
			 * not call compaction as it is expected that the
			 * necessary pages are already available.
			 */
			if (pgdat_needs_compaction &&
					zone_watermark_ok(zone, order,
						low_wmark_pages(zone),
						*classzone_idx, 0))
				pgdat_needs_compaction = false;
		}

		/*
		 * If we're getting trouble reclaiming, start doing writepage
		 * even in laptop mode.
		 */
		if (sc.priority < DEF_PRIORITY - 2)
			sc.may_writepage = 1;

```

