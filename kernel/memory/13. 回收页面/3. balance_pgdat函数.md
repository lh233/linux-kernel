balance_pgdat 函数是回收页面的主函数。这个函数比较长，首先看一个框架，主体函数是一个很长的while循环，简化后的代码如下：

```
[balance_pgdat()函数总体框架]
static unsigned long balance_pgdat(pg_data_t *pgdat, int order,
							int *classzone_idx)
{
	struct scan_control sc = {
		.gfp_mask = GFP_KERNEL,
		.order = order,
		.priority = DEF_PRIORITY,
		.may_writepage = !laptop_mode,
		.may_unmap = 1,
		.may_swap = 1,
	};
	...
	do {
		//从高端zone往低端zone方向查找第一个处于不平衡的end_zone
		for (i = pgdat->nr_zones - 1; i >= 0; i--) {
			struct zone *zone = pgdat->node_zones + i;
			...
			if (!zone_balanced(zone, order, 0, 0)) {
				end_zone = i;
				break;
			}
		}
		
		//从最低端zone开始页面回收，一直到end_zone
		for (i = 0; i <= end_zone; i++) {
			struct zone *zone = pgdat->node_zones + i;
			kswapd_shrink_zone(zone, end_zone,
					       &sc, &nr_attempted);
		}
		//不断加大扫码粒度，并且检查最低端zone到classzone_idx的zone是否处于平衡状态
	}while (sc.priority >= 1 &&
		 !pgdat_balanced(pgdat, order, *classzone_idx));
}
```

struct scan_control数据结构用于控制页面回收的参数，例如要回收页面的个数nr_to_reclaim、分配掩码gfpmask、分配的阶数order（2order个页面）、扫描LRU链表的优先级priority等。priority成员表示扫描的优先级，用于计算每次扫描页面的数量，计算方法是total_size>>priority，初始值为12，依次递减。priority数值越低，扫描的页面数量越大，相当于逐步加大扫描粒度。struct_scan_control数据结构定义在mm/vmscan.c文件中。

```
[mm/vmscan.c]
struct scan_control {
	/* How many pages shrink_list() should reclaim */
	unsigned long nr_to_reclaim;

	/* This context's GFP mask */
	gfp_t gfp_mask;

	/* Allocation order */
	int order;

	/*
	 * Nodemask of nodes allowed by the caller. If NULL, all nodes
	 * are scanned.
	 */
	nodemask_t	*nodemask;

	/*
	 * The memory cgroup that hit its limit and as a result is the
	 * primary target of this reclaim invocation.
	 */
	struct mem_cgroup *target_mem_cgroup;

	/* Scan (total_size >> priority) pages at once */
	int priority;

	unsigned int may_writepage:1;

	/* Can mapped pages be reclaimed? */
	unsigned int may_unmap:1;

	/* Can pages be swapped as part of reclaim? */
	unsigned int may_swap:1;

	/* Can cgroups be reclaimed below their normal consumption range? */
	unsigned int may_thrash:1;

	unsigned int hibernation_mode:1;

	/* One of the zones is ready for compaction */
	unsigned int compaction_ready:1;

	/* Incremented by the number of inactive pages that were scanned */
	unsigned long nr_scanned;

	/* Number of pages freed so far during a call to shrink_zones() */
	unsigned long nr_reclaimed;
};
```

pgdat_balanced()需要注意参数classzone_idx，它表示在页面分配路径上计算出来第一个最合适内存分配的zone的编号，通过wake_all_kswapds()传递下来。

```
static bool pgdat_balanced(pg_data_t *pgdat, int order, int classzone_idx)
{
	unsigned long managed_pages = 0;
	unsigned long balanced_pages = 0;
	int i;

	/* Check the watermark levels */
	//遍历从最低端的zone到classzone_idx的页面是否处于平衡
	for (i = 0; i <= classzone_idx; i++) {
		struct zone *zone = pgdat->node_zones + i;

		if (!populated_zone(zone))
			continue;

		managed_pages += zone->managed_pages;

		/*
		 * A special case here:
		 *
		 * balance_pgdat() skips over all_unreclaimable after
		 * DEF_PRIORITY. Effectively, it considers them balanced so
		 * they must be considered balanced here as well!
		 */
		if (!zone_reclaimable(zone)) {
			balanced_pages += zone->managed_pages;
			continue;
		}

		if (zone_balanced(zone, order, 0, i))
			balanced_pages += zone->managed_pages;
		else if (!order)
			return false;
	}

	if (order)
		return balanced_pages >= (managed_pages >> 2);
	else
		return true;
}
```

注意参数classzone_idx是由页面分配路径上传递过来的。pgdat_balanced()判断一个内存节点上的物理页面是否处于平衡状态，返回true，则表示该内存节点处于平衡状态。注意第7行代码，遍历从最低端的zone到classzone_idx的页面是否处于平衡状态。