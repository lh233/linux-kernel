在最近几十年操作系统的发展过程中，有很多页面交换算法，其中每个算法都有各自的优点和缺点。Linux内核中采用的页交换算法主要是LRU算法和第二次机会法（second chance)。

## 1.LRU链表

LRU是least recently used（最近最少使用）的缩写，LRU假定最近不使用的页在较短的时间内也不会频繁使用。在内存不足时，这些页面将成为被换出的候选者。内核使用双向链表来定义LRU链表，并且根据页面的类型分为LRU_ANON和LRU_FILE。每种类型根据页面的活跃性分为活跃LRU和不活跃LRU，所以内核中一共有如下5个LRU链表。

- 不活跃匿名页面链表LRU_INACTIVE_ANON。
- 活跃匿名页面链表LRU_ACTIVE_ANON。
- 不活跃文件映射页面链表LRU_INACTIVE_FILE。
- 活跃文件映射页面链表LRU_ACTIVE_FILE。
- 不可回收页面链表LRU_UNEVICTABLE。

LRU链表之所以要分成这样，是因为当内存紧缺时总是优先换出page cache页面，而不是匿名页面。因为大多数情况page cache 页面下不需要回写磁盘，除非页面内容被修改了，而匿名页面总是要被写入交换分区才能被换出。LRU链表按照zone来配置，也就是每个zone中都有一整套LRU链表，因此zone数据结构中有一个成员lruvec指向这些链表。枚举类型变量lrulist列举出上述各种LRU链表的类型，struct lruvec数据结构中定义了上述各种LRU类型的链表。

```
#define LRU_BASE 0
#define LRU_ACTIVE 1
#define LRU_FILE 2

enum lru_list {
	LRU_INACTIVE_ANON = LRU_BASE,
	LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,
	LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,
	LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,
	LRU_UNEVICTABLE,
	NR_LRU_LISTS
};

struct lruvec {
	struct list_head lists[NR_LRU_LISTS];
	struct zone_reclaim_stat reclaim_stat;
};

struct zone {
	...
	struct lruvec lruec;
	...
}
```

LRU链表是如何实现页面老化的呢？

这需要从页面如何加入LRU链表，以及LRU链表摘取页面说起。加入LRU链表的常用API是lru_cache_add()。

```
[lru_cache_add() -> __lru_cache_add()]
static void __lru_cache_add(struct page *page)
{
	struct pagevec *pvec = &get_cpu_var(lru_add_pvec);

	page_cache_get(page);
	if (!pagevec_space(pvec))
		__pagevec_lru_add(pvec);
	pagevec_add(pvec, page);
	put_cpu_var(lru_add_pvec);
}
```

这里使用了页向量（pagevec）数据结构，借助一个数组来保存特定数目的页，可以对这些页面执行同样的操作。页向量会以“批处理的方式”执行，比单独处理一个页的方式效率要高。页向量数据结构的定义如下：

```
#define PAGEVEC_SIZE	14
struct pagevec {
	unsigned long nr;
	unsigned long cold;
	struct page *pages[PAGEVEC_SIZE];
};
```

\_Iru_cache_add()函数第5行代码判断页向量pagevec是否还有空间，如果没有空间，那么首先调用\__pagevec_lru_add()函数把原有的page加入到LRU链表中，然后把新页面添加到页向量pagevec中。

```
static void __pagevec_lru_add_fn(struct page *page, struct lruvec *lruvec,
				 void *arg)
{
	int file = page_is_file_cache(page);
	int active = PageActive(page);
	enum lru_list lru = page_lru(page);
	SetPageLRU(page);
	add_page_to_lru_list(page, lruvec, lru);
}
static __always_inline void add_page_to_lru_list(struct page *page,
				struct lruvec *lruvec, enum lru_list lru)
{
	int nr_pages = hpage_nr_pages(page);
	list_add(&page->lru, &lruvec->lists[lru]);
}
```

从add_page_to_lru_list()可以看到，一个page 最终通过list_add()函数来加入LRU链表，list_add()会将成员添加到链表头。

Iru_to_page(&lru_list)和list_del(&page->lru)函数组合实现从LRU链表摘取页面，其中，Iru_to_page()的实现如下：

```
[mm/vmscan.c]
#define lru_to_page(_head)(list_entry((_head)->prev,struct page,lru))
```

lru_to_page()使用了head->prev，从链表的末尾摘取页面，因此，LRU链表实现了先进先出（FIFO）算法。最先进入LRU链表的页面，在LRU中的时间会越长，老化时间也越长。

在系统运行过程中，页面总是在活跃LRU链表和不活跃LRU链表之间转移，不是每次访问内存页面都会发生这种转移。而是发生的时间间隔比较长，随着时间的推移，导致一种热平衡，最不常用的页面将慢慢移动到不活跃LRU链表的末尾，这些页面正是页面回收中最合适的候选者。

经典LRU链表算法如图2.27所示。

![经典LRU链表算法](picture/经典LRU链表算法.png)

## 2.第二次机会法

第二次机会法（second chance）在经典LRU算法基础上做了一些改进。在经典LRU链表（FIFO)中，新产生的页面加入到LRU链表的开头，将LRU链表中现存的页面向后移动了一个位置。当系统内存短缺时，LRU链表尾部的页面将会离开并被换出。当系统再需要这些页面时，这些页面会重新置于LRU链表的开头。显然这个设计不是很巧妙，在换出页面时，没有考虑该页面的使用情况是频繁使用，还是很少使用。也就是说，频繁使用的页面依然会因为在LRU链表末尾而被换出。

第二次机会算法的改进是为了避免把经常使用的页面置换出去。当选择置换页面时，依然和LRU算法一样，选择最早置入链表的页面，即在链表末尾的页面。二次机会法设置了一个访问状态位（硬件控制的比特位），所以要检查页面的访问位。如果访问位是0，就淘汰这页面；如果访问位是1，就给它第二次机会，并选择下一个页面来换出。当该页面得到第二次机会时，它的访问位被清0，如果该页在此期间再次被访问过，则访问位置为1。这样给了第二次机会的页面将不会被淘汰，直至所有其他页面被淘汰过（或者也给了第二次机会）。因此，如果一个页面经常被使用，其访问位总保持为1，它一直不会被淘汰出去。





Linux 内核使用PG_active和PG_referenced这两个标志位来实现第二次机会法。PG_active表示该页是否活跃，PG_referenced表示该页是否被引用过，主要函数如下。

- mark_page_accessed()。

- page_referenced()。

- page_check_references();

  

## 3. mark_page_accessed()

下面来看mark_page_accessed()函数。

```
void mark_page_accessed(struct page *page)
{
	if (!PageActive(page) && !PageUnevictable(page) &&
			PageReferenced(page)) {
		if (PageLRU(page))
			activate_page(page);
		else
			__lru_cache_activate_page(page);
		ClearPageReferenced(page);
		if (page_is_file_cache(page))
			workingset_activation(page);
	} else if (!PageReferenced(page)) {
		SetPageReferenced(page);
	}
}
```

（1）如果PG_active=0&&PG_referenced=1,则：

- 把该页加入活跃LRU，并设置PG_active=1；
- 清PG_referenced标志位。

（2）如果PG_referenced=0，则：

- 设置PG_referenced标志位。



## 4. page_check_reference()

下面来看page_check_references()函数。

```
[mm/vmscan.c]
static enum page_references page_check_references(struct page *page,
						  struct scan_control *sc)
{
	int referenced_ptes, referenced_page;
	unsigned long vm_flags;

	referenced_ptes = page_referenced(page, 1, sc->target_mem_cgroup,
					  &vm_flags);
	referenced_page = TestClearPageReferenced(page);

	if (vm_flags & VM_LOCKED)
		return PAGEREF_RECLAIM;

	if (referenced_ptes) {
		if (PageSwapBacked(page))
			return PAGEREF_ACTIVATE;
			
		SetPageReferenced(page);

		if (referenced_page || referenced_ptes > 1)
			return PAGEREF_ACTIVATE;

		/*
		 * Activate file-backed executable pages after first usage.
		 */
		if (vm_flags & VM_EXEC)
			return PAGEREF_ACTIVATE;

		return PAGEREF_KEEP;
	}

	/* Reclaim if clean, defer dirty pages to writeback */
	if (referenced_page && !PageSwapBacked(page))
		return PAGEREF_RECLAIM_CLEAN;

	return PAGEREF_RECLAIM;
}
```

在扫描不活跃LRU链表时，page_check_references()会被调用，返回值是一个page_references的枚举类型。PAGEREF_ACTIVATE表示该页面会迁移到活跃链表，PAGEREF_KEEP 表示会继续保留在不活跃链表中，PAGEREF_RECLAIM和PAGEREF_RECLAIM_CLEAN表示可以尝试回收该页面。

第6行代码中的page_referenced()检查该页有多少个访问引用pte（referenced_ptes)。

第7行代码中的TestClearPageReferenced()函数返回该页面PG_referenced标志位的值（referenced page)，并且清该标志位。

接下来的代码根据访问引用pte的数目（referenced ptes变量）和PG_referenced标志位状态（referenced_page变量）来判断该页是留在活跃LRU、不活跃LRU，还是可以被回收。当该页有访问引用pte时，要被放回到活跃LRU链表中的情况如下。

- 该页是匿名页面（PageSwapBacked(page)）。
- 最近第二次访问的page cache 或共享的page cache。
- 可执行文件的page cache。

其余的有访问引用的页面将会继续保持在不活跃LRU链表中，最后剩下的页面就是可以回收页面的最佳候选者。

第17~19行代码，如果有大量只访问一次的page cache充斥在活跃LRU链表中，那么在负载比较重的情况下，选择一个合适回收的候选者会变得越来越困难，并且引发分配内存的高延迟，将错误的页面换出。这里的设计是为了优化系统充斥着大量只使用一次的page cache页面的情况（通常是mmap映射的文件访问），在这种情况下，只访问一次的page cache页面会大量涌入活跃LRU链表中，因为shrink_inactive_list()会把这些页面迁移到活跃链表，不利于页面回收。

mmap映射的文件访问通常通过filemap_fault()函数来产生page cache，在Linux 2.6.29以后的版本中，这些page cache 将不会再调用mark_page_accessed()来设置PG_referenced。因此对于这种页面，第一次访问的状态是有访问引用pte，但是PG_referenced=0，所以扫描不活跃链表时设置该页为PG_referenced，并且继续保留在不活跃链表中而没有被放入活跃链表。

在第二次访问时，发现有访问引用pte但PG_referenced=1，这时才把该页加入活跃链表中。因此利用PG_referenced做了一个page cache的访问次数的过滤器，过滤掉大量的短时间（多给了一个不活跃链表老化的时间）只访问一次的page cache。这群在内存短缺的情况下，kswapd就巧妙地释放了大量短时间只访问一次的page cache。这种大量只访问一次的page cache在不活跃LRU链表中多待一点时间，就越有利于在系统内存短缺时首先把它们释放了，否则这些页面跑到活跃LRU链表，再想把它们释放，那么要经历一个：

```
活跃LRU链表遍历时间+不活跃LRU链表遍历时间
```

第18行代码，“referenced_ptes>1”表示那些第一次在不活跃LRU链表中shared page cache，也就是说，如果有多个文件同时映射到该页面，它们应该晋升到活跃LRU链表中，因为它们应该多在LRU链表中一点时间，以便其他用户可以再次访问到。

总结page_check _references()函数的主要作用如下。

（1）如果有访问引用pte，那么：

- 该页是匿名页面（PageSwapBacked(page)），则加入活跃链表
- 最近第二次访问的page cache或shared page cache，则加入活跃链表；
- 可执行文件的page cache，则加入活跃链表；
- 除上述三种情况外，继续留在不活跃链表，例如第一次访问的page cache。

（2）如果没有访问引用pte，则表示可以尝试回收它。



## 5. page_referenced()

下面来看page_referenced()函数的实现。

```
[page_check_references()->page_referenced()]
int page_referenced(struct page *page,
		    int is_locked,
		    struct mem_cgroup *memcg,
		    unsigned long *vm_flags)
{
	int ret;
	int we_locked = 0;
	struct page_referenced_arg pra = {
		.mapcount = page_mapcount(page),
		.memcg = memcg,
	};
	struct rmap_walk_control rwc = {
		.rmap_one = page_referenced_one,
		.arg = (void *)&pra,
		.anon_lock = page_lock_anon_vma_read,
	};

	*vm_flags = 0;
	if (!page_mapped(page))
		return 0;

	if (!page_rmapping(page))
		return 0;

	if (!is_locked && (!PageAnon(page) || PageKsm(page))) {
		we_locked = trylock_page(page);
		if (!we_locked)
			return 1;
	}

	ret = rmap_walk(page, &rwc);
	*vm_flags = pra.vm_flags;

	if (we_locked)
		unlock_page(page);

	return pra.referenced;
}
```

page_referenced()函数判断 page是否被访问引用过，返回的访问引用pte的个数，即访问和引用（referenced）这个页面的用户进程空间虚拟页面的个数。核心思想是利用反向映射系统来统计访问引用pte的用户个数。第11行代码的rmap_walk_control数据结构中定义了rmap_one()函数指针。第18行代码，用page_mapped0判断 page->_mapcount引用计数是否大于等于0。第21行代码，用page_rmapping()判断page->mapping是否有地址空间映射。第39行代码，rmap_walk()遍历该页面所有映射的pte，然后调用rmap_one0函数。

```
[shrink_active_list()->page_referenced()->rmap_walk()->rmap_one()]

```

