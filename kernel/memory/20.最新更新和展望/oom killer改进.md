OOM Killer 的改进主要有OOM检测和OOM 收割机（reaper)。

那么如何知道系统当前时刻应该执行OOM Killer呢?因为系统内存使用状态是高度变化的，当前时刻分配内存失败不代表下一个时刻这些需要的内存不可以被分配出来，贸然调用OOM Killer这种笨重的武器会导致“杀敌一千自损八百”，所以最好是不要贸然行动，也许内核可以很快讨回所需要的内存。现在的内核在这方面变得有些“鲁莽”和不可预测，因为它有时会鲁莽地调用OOM killer，有时候也会等待很长的时间。

系统分配内存失败时会调用直接回收机制(direct reclaim）来回收一些内存。有些情况下直接回收机制返回成功，但有些情况下回收页面需要等待脏的内容写回磁盘，此时这些脏页面是不可用，虽然它们最终会变成空闲页面，但时间不确定，因此目前的内核会勉强调用OOMKiller。这个问题的关键是没有一个标准来界定这些正在回收的页面何时会变成空闲页面。

在Linux 4.7中，社区专家Michal Hocko提出了新的OOM检测机制R:系统分配内存失败时，特别是如果到最后调用直接回收机制（__alloc_pages_direct_reclaim()）还是失败,它会去不断尝试并检测当前的空闲页面和可回收页面（reclaimable pages）是否满足分配的需求,最多会尝试16次，只有这些尝试都失败才会去调用OOM Killer。当然有时调用OOM Killer比无谓地尝试和等待要好，因此如果上述尝试是失败的，那么在计算可回收页面数量时会“打折”，减少无谓的尝试和等待。

下面来看OOM 收割机。我们一般认为OOM Killer 的出现一定能回收了进程使用的内存，但是仍有例外。内核开发者Tetsuo Handa提出了如下的场景4:

（1）进程A执行XFS文件系统某些操作时需要分配一些内存。

（2）内存管理子系统会尝试分配所需要的内存，如果分配失败，首先尝试直接内存回收机制（direct reclaim）去强制回收内存，如果继续失败，那么会调用OOM Killer。

(3 )OOM killer会选择一个进程B来尝试回收。

(4）进程B为了退出需要执行一些XFS文件系统的操作，这些操作会申请锁，恰巧进程A持有这个锁,这时会发生死锁。

所以在上述场景中，进程A无法分配出所需要的内存，OOM Killer 也遇到了对手。为此Michal Hocko提出了OOM收割机的机制，当一个进程收到SIGKILL信号时，代表它不会在用户态继续运行，可以在进程被销毁之前收割其拥有的匿名页面。OOM 收割机的实现比较简单，它会创建一个名为“oom_reaper”的内核线程来做内存收割。

