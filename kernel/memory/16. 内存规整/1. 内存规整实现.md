内存规整的一个重要的应用场景是在分配大块内存时（order>1），在WMARK_LOW低水位情况下分配失败，唤醒kswapd内核线程后依然无法分配出内存，这时调用_alloc_pages_direct_compact()来压缩内存尝试分配出所需要的内存。下面沿着 alloc_pages0->..>alloc_pages_direct_compact()这条内核路径来看内存规整是如何工作的。

```
[mm/page_alloc.c] 
[alloc_pages()->_alloc_pages_nodemask()->__alloc_pages_slowpath()-> __alloc_pages_direct_compact()]
/* Try memory compaction for high-order allocations before reclaim */
static struct page *
__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,
		int alloc_flags, const struct alloc_context *ac,
		enum migrate_mode mode, int *contended_compaction,
		bool *deferred_compaction)
{
	unsigned long compact_result;
	struct page *page;

	if (!order)
		return NULL;

	current->flags |= PF_MEMALLOC;
	compact_result = try_to_compact_pages(gfp_mask, order, alloc_flags, ac,
						mode, contended_compaction);
	current->flags &= ~PF_MEMALLOC;

	switch (compact_result) {
	case COMPACT_DEFERRED:
		*deferred_compaction = true;
		/* fall-through */
	case COMPACT_SKIPPED:
		return NULL;
	default:
		break;
	}

	/*
	 * At least in one zone compaction wasn't deferred or skipped, so let's
	 * count a compaction stall
	 */
	count_vm_event(COMPACTSTALL);

	page = get_page_from_freelist(gfp_mask, order,
					alloc_flags & ~ALLOC_NO_WATERMARKS, ac);

	if (page) {
		struct zone *zone = page_zone(page);

		zone->compact_blockskip_flush = false;
		compaction_defer_reset(zone, order, true);
		count_vm_event(COMPACTSUCCESS);
		return page;
	}

	/*
	 * It's bad if compaction run occurs and fails. The most likely reason
	 * is that pages exist, but not enough to satisfy watermarks.
	 */
	count_vm_event(COMPACTFAIL);

	cond_resched();

	return NULL;
}
```

内存规整是针对high-order的内存分配，所以order等于0的情况不需要触发内存规整。参数 mode 指migration_mode，通常由_alloc_pages_slowpath()传递过来，其值为MIGRATE_ASYNC。
    try_to_compact_pages()函数执行时需要设置当前进程的PF_MEMALLOC标志位，该标志位会在