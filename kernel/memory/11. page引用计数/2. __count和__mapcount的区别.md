\_count和\_mapcount是struct page数据结构中非常重要的两个引用计数，且都是atomic_t类型的变量，其中，count表示内核中引用该页面的次数。当_count的值为0时，表示该page页面为空闲或即将要被释放的页面。当count的值大于0时，表示该page页面已经被分配且内核正在使用，暂时不会被释放。

内核中常用的加减_count 引用计数的API为get page()和put page()。

```
[include/linux/mm.h]
static inline void get_page(struct page *page)
{
	if (unlikely(PageTail(page)))
		if (likely(__get_page_tail(page)))
			return;
	/*
	 * Getting a normal page or the head of a compound page
	 * requires to already have an elevated page->_count.
	 */
	VM_BUG_ON_PAGE(atomic_read(&page->_count) <= 0, page);
	atomic_inc(&page->_count);
}
static inline int put_page_testzero(struct page *page)
{
	VM_BUG_ON_PAGE(atomic_read(&page->_count) == 0, page);
	return atomic_dec_and_test(&page->_count);
}
[mm/swap.c]
void put_page(struct page *page)
{
	if (unlikely(PageCompound(page)))
		put_compound_page(page);
	else if (put_page_testzero(page))
		__put_single_page(page);
}
```

get_page()首先利用VM_BUG_ON_PAGE()来判断页面的_count的值不能小于等于0，这是因为页面伙伴分配系统分配好的页面初始值为1，然后直接使用atomic_inc()函数原子地增加引用计数。

put_page()首先也会使用VM_BUG_ON_PAGE()判断\_count 计数不能为0，如果为0，说明这页面已经被释放了。如果_count 计数减1之后等于0，就会调用put_single_page()来释放这个页面。

内核还有一对常用的变种宏，如下：

```
#define page_cache_get(page)		get_page(page)
#define page_cache_release(page)	put_page(page)
```

_count 引用计数通常在内核中用于跟踪page页面的使用情况，常见的用法归纳总结如下。

（1）分配页面时\_count引用计数会变成1。分配页面函数alloc_pages()在成功分配页面后，\_count 引用计数应该为0，这里使用VM_BUG_ON_PAGE()做判断，然后再设置这些页面的_count 引用计数为1，见set_spage_count()函数。

```
[alloc_pages()->_alloc_pages_nodemask()->get_page_from_freelist()->prep_new_page()->set_page_refcounted()]
static inline void set_page_refcounted(struct page *page)
{
	VM_BUG_ON_PAGE(PageTail(page), page);
	VM_BUG_ON_PAGE(atomic_read(&page->_count), page);
	set_page_count(page, 1);
}
```

（2）加入LRU链表时，page页面会被kswapd内核线程使用，因此\_count引用计数会加1。以malloc为用户程序分配内存为例，发生缺页中断后do_anonymous_page()函数成功分配出来一个页面，在设置硬件pte表项之前，调用lru_cache_add()函数把这个匿名页面添加到LRU链表中，在这个过程中，使用page_cache_get()宏来增加_count引用计数。