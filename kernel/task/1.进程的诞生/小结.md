在阅读本节前请思考如下小问题。

-   在内核中如何获取当前进程的task_struct 数据结构?
-   下面程序会打印出几个“_”?

```
int main (void)
{
	int i;
	for (i=0; i<2;i++){
		fork() ;
		printf( "_Nn" );
	}
	wait(NULL);
	wait(NULL);
	return 0 ;
}
```

-   用户空间进程的页表是什么时候分配的,其中一级页表什么时候分配?二级页表呢?

-   请简述fork，vfork和clone之间的区别?

进程是 Linux内核最基本的抽象之一，它是处于执行期的程序，或者说“进程=程序+执行”。但是进程并不仅局限于一段可执行代码（代码段)，它还包括进程需要的其他资源,例如打开的文件、挂起的信号量、内存管理、处理器状态、一个或者多个执行线程和数据段等。Linux内核通常把进程叫作是任务( task)，因此进程控制块( processing control block,PCB）也被命名为struct task struct。在20世纪60年代设计的分时操作系统进程最开始被称为工作（job)，后来改名为进程（process）。

线程被称为轻量级进程，它是操作系统调度的最小单元，通常一个进程可以拥有多个线程。线程和进程的区别在于进程拥有独立的资源空间，而线程则共享进程的资源空间。Linux内核并没有对线程有特别的调度算法或定义特别的数据结构来标识线程,线程和进程都使用相同的进程PCB数据结构。内核里使用clone方法来创建线程，其工作方式和创建进程fork方法类似，但会确定哪些资源和父进程共享，哪些资源为线程独享。

操作系统好比是一个人类社会，时时刻刻都有进程被创建或结束。进程自有它的生存之道，进程通常通过 fork系统调用来创新一个新的进程，新创建的进程可以通过exec()函数创建新的地址空间，并载入新的程序。进程结束可以自愿退出或非自愿退出。

本章主要讲述fork系统调用的实现。fork系统调用是所有进程的孵化器（idle进程除外)，因此本节重点讲解进程是如何被孵化出来的。fork 的实现会涉及到进程管理、内存管理、文件系统和信号处理等内容，本章会讲述一些核心的实现过程。