在阅读本节前请思考如下小问题。

-   下面程序会打印出几个“_”?

```
int main (void)
{
	int i;
	for (i=0; i<2;i++){
		fork() ;
		printf( "_Nn" );
	}
	wait(NULL);
	wait(NULL);
	return 0 ;
}
```

进程是 Linux内核最基本的抽象之一，它是处于执行期的程序，或者说“进程=程序+执行”。但是进程并不仅局限于一段可执行代码（代码段)，它还包括进程需要的其他资源,例如打开的文件、挂起的信号量、内存管理、处理器状态、一个或者多个执行线程和数据段等。Linux内核通常把进程叫作是任务( task)，因此进程控制块( processing control block,PCB）也被命名为struct task struct。在20世纪60年代设计的分时操作系统进程最开始被称为工作（job)，后来改名为进程（process）。

线程被称为轻量级进程，它是操作系统调度的最小单元，通常一个进程可以拥有多个线程。线程和进程的区别在于进程拥有独立的资源空间，而线程则共享进程的资源空间。Linux内核并没有对线程有特别的调度算法或定义特别的数据结构来标识线程,线程和进程都使用相同的进程PCB数据结构。内核里使用clone方法来创建线程，其工作方式和创建进程fork方法类似，但会确定哪些资源和父进程共享，哪些资源为线程独享。

操作系统好比是一个人类社会，时时刻刻都有进程被创建或结束。进程自有它的生存之道，进程通常通过 fork系统调用来创新一个新的进程，新创建的进程可以通过exec()函数创建新的地址空间，并载入新的程序。进程结束可以自愿退出或非自愿退出。

本章主要讲述fork系统调用的实现。fork系统调用是所有进程的孵化器（idle进程除外)，因此本节重点讲解进程是如何被孵化出来的。fork 的实现会涉及到进程管理、内存管理、文件系统和信号处理等内容，本章会讲述一些核心的实现过程。

-   在内核中如何获取当前进程的task_struct 数据结构?

在Linux内核中，task_struct是每个进程的核心数据结构，包含了管理进程所需的所有信息。要获取当前进程的task_struct数据结构，可以使用当前进程宏current，这个宏在进程的上下文中会返回一个指向当前进程task_struct结构的指针。
例如，在内核模块或内核函数中，你可以使用以下代码获取当前进程的task_struct：

```
#include <linux/sched.h>
struct task_struct *current_task;
current_task = current;  // 'current' is a pointer to the task_struct of the running process
```

如果你正在编写一个内核模块，不要忘记包含适当的头文件以访问必要的定义和结构。上面的代码示例中包含的<linux/sched.h>头文件就包括了对current宏的定义。

-   用户空间进程的页表是什么时候分配的,其中一级页表什么时候分配?二级页表呢?


在Linux系统中，用户空间进程的页表是在进程创建过程中分配的，这发生在内核的地址空间管理子系统中。

一级页表分配：
一级页表，也就是页全局目录（Page Global Directory, PGD），通常是在进程创建的时候分配的。在Linux内核中，这通常对应于fork()系统调用或其变体（如vfork()和clone()），这会通过复制或创建新的任务结构（task_struct）来创建进程。
在fork执行期间，内核会为新的进程分配一个新的mm_struct（内存描述符），该结构包含一个指向PGD的指针。具体地，PGD的初始化会在分配mm_struct之后进行，通常在设置用户空间内存时。Linux使用了懒惰分配（页面按需分配）来最小化资源占用，因此PGD在初始时可能只包含少量的实际映射。

二级页表分配：
二级页表，也就是页表项（Page Table Entries, PTEs），以及在分页系统的多级架构中的其他中间级别页表，例如页上目录（Page Upper Directory, PUD）和页中间目录（Page Middle Directory, PMD）（在四级分页体系结构中使用），它们通常是在页面首次被访问时按需分配的。这意味着，当进程尝试访问之前未映射的内存区域时，内核会进行缺页中断处理（page fault handling），并创建必要的页面映射。


总的来说，页表的创建和分配在Linux中是一个按需和动态的过程。一级页表（PGD）在进程创建时初始化，而二级页表（PTEs）以及可能的其他级别页表在进程运行中按需创建。这种设计允许系统以更有效的方式动态地管理内存资源。





-   请简述fork，vfork和clone之间的区别?

fork, vfork, 和 clone 是在 Unix-like操作系统中用于创建新进程的系统调用。下面是它们之间的主要区别：


fork:

fork() 是最传统的用于创建新进程的系统调用。
当一个进程调用 fork()，它会创建一个新的子进程，这个子进程是父进程的复制。
子进程获得父进程数据段、堆和栈的复制。
fork() 对父进程和子进程返回不同的值：对子进程返回 0，对父进程返回子进程的 PID。
fork() 通过复制页面表项来实现 copy-on-write (COW) 机制，意味着仅当父进程或子进程尝试修改页面内容时，页面的实际复制才会发生。



vfork:

vfork() 类似于 fork()，但它不复制父进程的页面表项。
vfork() 用于创建新进程时不需要复制整个父进程地址空间的情况。
与 fork() 不同，vfork() 保证子进程先运行，在子进程调用 exec() 或 exit() 之后，父进程才会继续运行。
vfork() 主要用于创建子进程后立即执行一个新程序，这种用法避免了不必要的地址空间复制。



clone:

clone() 是 Linux 特有的系统调用，被设计为更加灵活的进程创建方式。
clone() 可以被视为 fork() 和 vfork() 的通用版本，允许用户指定父进程和子进程之间共享哪些资源，如文件描述符、堆栈、内存空间等。
clone() 可用于创建线程（轻量级进程），因为线程分享同一进程的地址空间。
使用 clone() 最显著的特征是能够高度定制子进程和父进程之间共享的特性，使其成为创建轻量级进程或线程的理想选择。



这三个系统调用在创建新进程时各有优劣，开发者会根据其需要、性能要求以及资源共享的细粒度来选择适当的调用。随着操作系统的发展，你会发现 fork() 和 vfork() 慢慢地被 clone() 所取代，因为 clone() 提供了更多的灵活性。
