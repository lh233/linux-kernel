在Linux系统中，进程或线程是通过 fork、 vfork或clone等系统调用来建立的。在内核中,这3个系统的调用都是通过同一个函数来实现,即do_fork()函数,该函数定义在fork.c文件中。

```
long do_fork(unsigned long, unsigned long, unsigned long, int __user *, int __user *);
```

do_fork(函数有5个参数，具体含义如下。

- clone _flags:创建进程的标志位集合。
- stack_start:用户态栈的起始地址。
- stack_size:用户态栈的大小，通常设置为0。
- parent_tidptr和child_tidptr:指向用户空间中地址的两个指针,分别指向父子进程的PID。

clone _flags定义在sched.h文件中。

```
[include/uapi/linux/sched.h]
/*
*cloning flags:
*/
/*
 * cloning flags:
 */
#define CSIGNAL		0x000000ff	/* signal mask to be sent at exit */
#define CLONE_VM	0x00000100	/* set if VM shared between processes */
#define CLONE_FS	0x00000200	/* set if fs info shared between processes */
#define CLONE_FILES	0x00000400	/* set if open files shared between processes */
#define CLONE_SIGHAND	0x00000800	/* set if signal handlers and blocked signals shared */
#define CLONE_PTRACE	0x00002000	/* set if we want to let tracing continue on the child too */
#define CLONE_VFORK	0x00004000	/* set if the parent wants the child to wake it up on mm_release */
#define CLONE_PARENT	0x00008000	/* set if we want to have the same parent as the cloner */
#define CLONE_THREAD	0x00010000	/* Same thread group? */
#define CLONE_NEWNS	0x00020000	/* New mount namespace group */
#define CLONE_SYSVSEM	0x00040000	/* share system V SEM_UNDO semantics */
#define CLONE_SETTLS	0x00080000	/* create a new TLS for the child */
#define CLONE_PARENT_SETTID	0x00100000	/* set the TID in the parent */
#define CLONE_CHILD_CLEARTID	0x00200000	/* clear the TID in the child */
#define CLONE_DETACHED		0x00400000	/* Unused, ignored */
#define CLONE_UNTRACED		0x00800000	/* set if the tracing process can't force CLONE_PTRACE on this clone */
#define CLONE_CHILD_SETTID	0x01000000	/* set the TID in the child */
#define CLONE_NEWCGROUP		0x02000000	/* New cgroup namespace */
#define CLONE_NEWUTS		0x04000000	/* New utsname namespace */
#define CLONE_NEWIPC		0x08000000	/* New ipc namespace */
#define CLONE_NEWUSER		0x10000000	/* New user namespace */
#define CLONE_NEWPID		0x20000000	/* New pid namespace */
#define CLONE_NEWNET		0x40000000	/* New network namespace */
#define CLONE_IO		0x80000000	/* Clone io context */
```

- CLONE_VM：父进程和子进程运行在同一个虚拟地址空间，一个进程对全局变量改动，另外一个进程也可以看到。
- CLONE_FS：父进程和子进程共享文件系统信息，例如根目录、当前工作目录等。其中一个进程对文件系统信息进行改变，将会影啊到另外一个进程，例如调用chroot()或chdir()等。
- CLONE_FILES:父进程和子进程共享文件描述符表。文件描述符表里面保存进程打开文件描述符的信息，因此一个进程打开的文件，在另外一个进程用同样的描述符也可以访问。一个进程关闭了一个文件或者使用fcntl()改变了一个文件属性，另外一个进程也能看到。
- CLONE_SIGHAND：父进程和子进程共享信号处理器函数表。一个进程改变了某个信号处理函数，这个改动对于另外一个进程也有效。
- CLONE_PTRACE：父进程被跟踪（ptrace)，子进程也会被跟踪。
- CLONE_VFORK：在创建子进程时启用Linux内核的完成机制（completion）。wait_for_completion()会使父进程进入睡眠等待，直到子进程调用execve()或exit()释放虚拟内存资源。