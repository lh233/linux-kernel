Linux内核作为一个通用操作系统，需要兼顾各种各样类型的进程，包括实时进程、交互式进程、批处理进程等。每种类型进程都有其特别的行为特征，总结如下。

-   交互式进程:与人机交互的进程，和鼠标、键盘、触摸屏等相关的应用，例如vim编辑器等，它们一直在睡眠同时等待用户召唤它们。这类进程的特点是系统响应时间越快越好，否则用户就会抱怨系统卡顿。
-   批处理进程:此类进程默默地工作和付出，可能会占用比较多的系统资源，例如编译代码等。
-   实时进程:有些应用对整体时延有严格要求，例如现在很火的 VR设备，从头部转动到视频显示需要控制到19毫秒以内，否则会使人出现眩晕感。，对于工业控制系统，不符合要求的时延可能会导致严重的事故。

本节主要讲述普通进程的调度，包括交互进程和批处理进程等。在CFS 调度器出现之前，早期Linux内核中曾经出现过两个调度器，分别是O(N)和O(1)调度器。O(N)调度器发布于1992年，该调度器算法比较简洁，从就绪队列中比较所有进程的优先级，然后选择一个最高优先级的进程作为下一个调度进程。每个进程有一个固定时间片，当进程时间片使用完之后，调度器会选择下一个调度进程，当所有进程都运行一遍后再重新分配时间片。这个调度器选择下一个调度进程前需要遍历整个就绪队列，花费O(N)时间。

在Linux 2.6.23内核之前有一款名为O(1)的调度器，优化了选择下一个进程的时间。它为每个CPU维护一组进程优先级队列，每个优先级一个队列，这样在选择下一个进程时，只需要查询优先级队列相应的位图即可知道哪个队列中有就绪进程，所以查询时间为常数O(1)。

O(1)调度器在处理某些交互式进程时依然存在问题，特别是有一些测试场景下导致交互式进程反应缓慢，另外对NUMA支持也不完善，因此大量难以维护和阅读的代码被加入该调度器中。Linux内核社区的一位传奇人物Con Kolivas提出了RSDL(楼梯调度算法）来实现公平性,在社区的一番争论之后，RedHat 公司的Ingo Molnar借鉴RSDL 的思想提出一个CFS调度算法。

不同的进程采用不同的调度策略，目前Linux内核中默认实现了4种调度策略，分别是deadline、realtime、CFS和 idle，它们分别使用struct sched_class来定义调度类。

这4种调度类通过next 指针串联在一起，用户空间程序可以使用调度策略API函数(sched_setscheduler()R)来设定用户进程的调度策略。其中，SCHED_NORMAL和 SCHED_BATCH使用CFS调度器，SCHED_FIFO和SCHED_RR使用realtime调度器，SCHED_IDLE指idle调度，SCHED_ DEADLINE指deadline调度器。

```
/*
 * Scheduling policies
 */
#define SCHED_NORMAL		0
#define SCHED_FIFO		1
#define SCHED_RR		2
#define SCHED_BATCH		3
/* SCHED_ISO: reserved but not implemented yet */
#define SCHED_IDLE		5
#define SCHED_DEADLINE		6
```

