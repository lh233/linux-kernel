-   请简述对进程调度器的理解，早期Linux内核调度器（包括O(N)和O(1))调度器是如何工作的?

进程调度器是操作系统内核的一部分，负责管理系统上所有进程的执行。它决定哪个进程可以在CPU上运行、何时运行以及运行多久。进程调度器的目标是实现公平性、高效性和快速响应。
早期Linux内核的进程调度器：

-   O(N) 调度器：

在初期版本的Linux内核中，使用了一个基于时间片的调度算法，这个算法的时间复杂度为O(N)，其中N是可运行进程的数量。

-   O(N)调度器通常会遍历所有的进程，寻找最佳候选进程来进行下一次调度。
-   这种调度器简单易实现，但它在有大量进程时效率较低，因为必须遍历整个进程列表来做出调度决策。



-   O(1) 调度器：

随着Linux内核的发展，这种按照“完全公平”原则工作的调度算法变得不再适用，因为随着系统负载的增加，它的性能会大打折扣。
Linux内核引入了一种新的调度算法，称为O(1)调度器。这个调度器的命名来自于它进行调度决策的时间复杂度：与可运行进程的数量无关，即常数时间复杂度。

-   O(1)调度器维护两个优先级数组（一个用于实时任务，另一个用于普通任务），每一个优先级都有自己的运行队列。
-   调度器将根据不同优先级选择合适的进程来运行，并使用一种称为“位图”的机制以常数时间快速找到下一个可运行的进程。
-   O(1)调度器通过维护活跃和过期两种任务队列来平衡任务的运行时间。一旦进程消耗完它的时间片，它就会移动到过期队列中。当活跃队列为空时，两个队列的角色会互换。

尽管O(1)调度器提供了定时性能，但它对于不同类型的负载（如I/O密集型任务、交互式任务）并不总是最优的。因此，在Linux 2.6.23版本中，O(1)调度器被完全公平调度器（CFS，Completely Fair Scheduler）替代，后者旨在提供更好的响应时间和过载时的性能。
CFS使用红黑树数据结构来有效管理进行调度的任务，其调度复杂度接近O(log N)，并且它更加关注于每个进程获得的CPU时间份额来实现公平性，而不是仅仅依赖于硬编码的时间片。这使得它在处理现代多核处理器和各种类型的负载方面更为高效和公平。



-   请简述进程优先级、nice和权重之间的关系。

在Linux操作系统中，进程的调度优先级决定了一个进程相对于其他进程在CPU时间分配上的优先考虑。不同类型的进程，如实时进程和常规进程，可能有不同的优先级机制。

-   进程优先级

实时优先级（Real-time Priority）：
实时进程有一个优先级范围，通常从1到99。在这个范围内，数字越小表示优先级越高。实时进程通常用于需要即时或确定性响应的任务。

常规优先级（Nice Value）：
对于非实时进程，Linux内核使用一个叫做nice值的概念。nice值的范围是从-20（最高优先级）到19（最低优先级）。nice值实际上是一个用户级的控制手段，允许调整进程的优先级。

-   Nice和权重

nice值直接影响进程的权重（weight）。权重是内核用来计算进程挑选为运行状态的概率的一个因子。nice值越低（数值更负），进程的权重越大，被调度器选择运行的机会越多。
在Linux 2.6.23之后，引入了完全公平调度器（CFS）。CFS不使用静态优先级列表，而是为每个进程维护一个动态优先级，即虚拟运行时间。nice值影响了进程获得的虚拟运行时间，nice值低（即优先级高）的进程会获得更多的CPU时间。

总的来说，在CFS中，进程的权重（由nice值决定），会影响它与其他进程相比获得CPU时间的比例。当两个进程的CPU时间使用和nice值都相同时，它们在CPU时间分配上应该是公平的。但是如果nice值不同，拥有较低nice值（因而较高权重）的进程将获得更多的CPU时间。CFS的目标是确保长期来看，每个进程都能获得它应该得到的CPU时间份额。
简而言之，进程优先级、nice值和权重的关系如下：

实时优先级直接决定了实时进程的调度顺序。
非实时进程的调度取决于nice值，它影响进程的权重。
调度器根据进程的权重和其他因素（如虚拟运行时间）来动态地决定进程的调度优先级。



-   请简述CFS调度器是如何工作的。

CFS调度器（Completely Fair Scheduler）是Linux内核的调度器之一，自Linux 2.6.23版本开始引入。它主要设计目标是提供尽可能公平的CPU分配给系统中的所有进程，即确保每个进程获得合理的CPU时间份额。
以下是CFS调度器工作原理的简述：

-   虚拟运行时间（Virtual Runtime）:
    CFS使用虚拟运行时间来衡量进程对CPU的利用率。虚拟运行时间是进程实际运行时间经过某种加权机制调整后的时间。权重通常与进程的优先级有关。
-   红黑树（Red-Black Tree）:
    CFS利用红黑树（一种自平衡的二叉查找树）来组织和跟踪所有可运行的进程。树中的每个节点代表一个进程，以其虚拟运行时间作为排序的键值。
-   选择下一个进程（Pick Next Task）:
    当需要选择下一个获得CPU执行权的进程时，CFS会从红黑树中选择虚拟运行时间最少的进程，因为这意味着该进程相对于其他进程获得的CPU时间较少。
-   时间切片（Time Slices）:
    每个进程获得一个时间切片（slice of time），在该时间内可以执行。CFS会尽量分配合理的时间切片给进程，以保证“公平”原则。
-   睡眠和唤醒（Sleep and Wake-up）:
    当进程进入睡眠状态（例如等待IO操作），它会被移出调度器的红黑树。一旦被唤醒，它又会被插入到树中，其位置取决于其虚拟运行时间。
-   负载平衡（Load Balancing）:
    CFS还负责在多核系统上平衡负载。它会周期性地检查是否有核心相对空闲或过载，并相应地迁移进程以平衡整个系统的负载。


CFS调度器的关键在于尝试量化“公平性”，通过仔细管理虚拟运行时间确保所有进程都能得到公平的处理，特别是在相同优先级的情况下。它特别适用于大量计算型或IO密集型的混合负载环境。通过调整各种参数和调度策略，CFS能够提供稳定可靠的调度性能，以满足现代操作系统的需求。



-   CFS调度器中vruntime是如何计算的?

CFS（Completely Fair Scheduler）调度器是Linux内核中负责管理进程调度的一部分，其核心目标是保证所有运行的进程获得公平的处理器时间。CFS调度器使用虚拟运行时间（vruntime）来衡量每个进程的运行时间，以便做出调度决策。
vruntime是进程的一个属性，代表该进程在逻辑上消耗的处理器时间，其计算考虑了进程优先级。以下是一个简化的vruntime计算方式：

1.  首先，进程的权重（weight）是根据进程的nice值计算出来的。nice值越低，权重越大。
2.  系统在调度时会尝试使所有进程的vruntime尽可能相同。当系统需要选择下一个要运行的进程时，它会选取具有最小vruntime值的进程。
3.  当一个进程运行时，它的vruntime增加的快慢与它的权重成反比。权重越高的进程（即优先级越高的进程），其vruntime增长得更慢，因而可以运行更长时间。
4.  在实际计算vruntime时，Linux调度器还会考虑系统的具体时钟频率，以及更复杂的调整因素，比如CPU亲和性、多核心调度和负载平衡等。

具体到代码层面，vruntime的更新通常会发生在每次时钟中断时，这使得调度器可以计算进程自上次运行以来消耗了多少虚拟时间，并据此更新其vruntime。这是一个不断进行的过程，确保了调度的公平性和响应性。
以上仅为对CFS调度器vruntime计算方法的一个总结，实际情况会更复杂，涉及许多内核特定的细节和优化措施。



-   vruntime是何时更新的?

在CFS调度器中，vruntime主要在以下两种情况下更新：

1.  时钟中断：Linux利用时钟中断（也称作调度器时钟或tick）来进行任务调度。在每个时钟中断发生时，当前运行中的进程的vruntime会根据其运行时间和权重得出一个增值，并更新到该进程的vruntime. 这样可以确保处于运行状态的进程的vruntime反映其最新的执行时间。
2.  调度事件：除了时钟中断之外，任何可能会引起进程切换的调度事件（比如进程主动放弃CPU时间，阻塞在I/O操作，以及由于进程终止或创建等原因引发的调度改变）都可能触发更新vruntime. 当调度器选择下一个要运行的进程时，如果当前运行的进程不再是vruntime最小的进程，它会被替换下来，这个时候它的vruntime也会得到更新以反映实际的运行时间。


通过这样的不断更新，CFS调度器能够确保每个进程根据其优先级获得相应的CPU时间，从而实现整体的公平性。在更新vruntime时，CFS调度器要考量的因素相对复杂，比如系统负载、进程的nice值、实际运行的时间等，以保证准确和公平地衡量各个进程的执行时间。



-   CFS调度器中的min_vruntime有什么作用?

在CFS（Completely Fair Scheduler）调度器中，min_vruntime是一个非常重要的概念，用以保证调度的公平性。min_vruntime字面意思是最小虚拟运行时间（minimum virtual runtime），它代表了系统中所有可运行进程的vruntime的最小值。这个值是调度器内部使用的，并且会随着调度器的决策而更新。
min_vruntime的主要作用包括：

1.  确定下一个要运行的进程：调度时，CFS调度器会从所有可运行的进程中选择vruntime最接近min_vruntime的进程。通常情况下，这通常也就是那个有最小vruntime的进程。
2.  保持调度的公平：CFS的目标是让每个进程都能获得公平的处理器时间。使用min_vruntime作为进程被调度的起点，可以避免某个进程获得过多的CPU时间，确保新的或长时间未运行的进程能够得到公平的调度机会。
3.  调整和防止负‘vruntime’：为了避免vruntime变为负数，min_vruntime提供了一个公共的参考点，在这个基础上vruntime进行增减。而当系统空闲时（即没有进程运行），min_vruntime还会继续推进，以确保新唤醒的进程能够尽快得到服务。


总之，min_vruntime是CFS调度器中一个关键的参数，用于维持进程间调度的公平性。这项机制也有助于避免某些进程因为vruntime的极端值而长时间被饿死（即得不到足够的CPU时间执行）。CFS调度器持续监控vruntime，并根据实时数据调整min_vruntime，确保系统中所有进程的运行都尽可能符合"完全公平"的原则。



-   CFS调度器对新创建的进程和刚唤醒的进程有何关照?

CFS调度器对新创建的进程和刚唤醒的进程采取了一些特殊的策略，以确保它们可以迅速并且公平地竞争处理器资源。以下是CFS调度器处理这两类进程的方法：

1.  新创建的进程：当一个新进程被创建时，CFS调度器赋予它的vruntime相对较小的初始值，通常设置为当前最小的min_vruntime值。这样做是为了确保新创建的进程能够较快地获得处理器资源，从而开始其执行。这弥补了新进程因为启动较晚而在计算vruntime上的不利。
2.  刚唤醒的进程：对于睡眠后在某个事件（如I/O完成）唤醒的进程，调度器会尝试将该进程的vruntime调整到一个合适的值，通常是接近当前min_vruntime的值，但不一定总是重置为min_vruntime本身。这样可以确保长时间睡眠的进程唤醒后可以合理地参与CPU资源的竞争。睡眠时间过长的进程在唤醒时其vruntime可能会被这样的策略更加显著地补偿，以防止饿死。

这两种情况中，CFS调度器的目标是防止由于等待和延迟导致的饿死现象，并且让新进程或长时间等待的进程有一个公平的出发点。通过这种调整，并不是直接让这些进程取得调度上的优势，而是让它们可以和其他已经在运行一段时间并积累了vruntime的进程一样有机会获得CPU时间。这些机制结合起来保证了调度的整体公平性。



-   如何计算普通进程的平均负载load_avg_contrib? runnable_avg_sum和runnable_avg_period分别是什么含义?

在计算普通进程的平均负载时，我们通常会使用 "load average" 这个指标。这个指标可以描述系统在特定时间内的负载情况。在Linux系统中，平均负载是通过对特定时间间隔内可运行队列中的进程数（即处于就绪状态和正在运行状态的进程数）进行平均来计算得出的。

平均负载的计算公式为：
load_avg_contrib = (runnable_avg_sum / runnable_avg_period)
其中：

-   runnable_avg_sum 是在一定时间间隔内可运行队列的进程数总和，也就是说，它是在这个时间间隔内所有采样点上的可运行进程数的累加值。
-   runnable_avg_period 是用于计算平均的时间段长度，通常以“时钟节拍”为单位。这个时间段通常是指定的几秒或者几分钟。

例如，如果我们考虑过去1分钟的时间，runnable_avg_period就是1分钟对应的时钟节拍数，runnable_avg_sum就是过去1分钟内每个时钟节拍中可运行进程数的累加值。通过这两个值的比值就可以得出过去1分钟的平均负载。
这个计算方法可以提供一个系统平均负载的实时估算，可以帮助系统管理员了解系统当前的性能状况以及它是否处于过载状态。通常情况下，平均负载越高，表示系统中有更多的进程等待处理，可能导致性能下降。如果平均负载远低于CPU核心数，则系统资源有较多余量；相反，如果平均负载远高于CPU核心数，则表明系统过载。





-   内核代码中定义了若干个表，请分别说出它们的含义，比如 prio_to_weight,  prio_to_wmult、 runnable_avg_yN_inv、runnable_avg_yN_sum。

在内核代码中，为了实现不同的功能和调度算法，会定义一些表格数据结构，这些表通常包含了一组相关数据，用于快速查找、计算或者用于实现某种映射关系。以下是一些典型的表及其含义：

1.  prio_to_weight：这个表是用来将进程的优先级（priority）映射到一个权重值（weight）上。在Linux的完全公平调度器（Completely Fair Scheduler, CFS）中，每个进程被赋予了一个权重值，该值用于决定其在CPU时间分配中的权重。prio_to_weight表提供了从静态优先级到权重的映射，可以用来快速查找对应的权重值。
2.  prio_to_wmult：这个表提供了从优先级到权重乘数（weight multiplier）的映射，它通常用于计算进程的运行时间。在CFS调度器中，进程的虚拟运行时间是通过实际运行时间乘以权重乘数来计算的。prio_to_wmult允许调度器快速获得适当的乘数，以执行这种计算。
3.  runnable_avg_yN_inv 和 runnable_avg_yN_sum：这两个表是与进程的平均运行队列相关的表。在CFS调度器中，每个进程维护着其可运行平均值的统计信息，该信息用于估算负载和其他调度决策。runnable_avg_yN_inv 是与平均负载计算相关的衰减率的倒数，而 runnable_avg_yN_sum 可能是与特定时间间隔内可运行的平均负载的累积值相关的表。具体的意义和用法取决于内核版本和调度器的实现细节。







-   如果一个普通进程在就绪队列里等待了很长时间才被调度，那么它的平均负载该如何计算?

在Linux操作系统中，完全公平调度器（Completely Fair Scheduler, CFS）是用于调度普通（非实时）进程的调度器。CFS尝试为每个运行的进程公平分配CPU时间。如果一个普通进程在就绪队列里等待了很长时间才被调度，它的“平均负载”（在这个上下文中更准确的术语可能是"运行队列负载贡献"或"负载权重"）会受到影响，因为CFS会通过增加进程的虚拟运行时间权重来补偿其等待时间。

在CFS中，每个进程都有一个“vruntime”，即虚拟运行时间，它是基于实际运行时间和权重的一个值。当一个进程等待得更长时，为了维持公平性，调度器可能会减少其vruntime，增加其权重，从而在调度决策时提高其优先级。这样，等待时间过长的进程能够更快地被调度。

平均负载的计算通常基于系统中所有进程的运行队列大小，而单个进程的平均负载计算可以通过以下步骤进行：

1.  记录进程在被放入运行队列的时刻的vruntime。
2.  计算进程在队列中等待的时间长度。
3.  对于过长的等待时间，CFS会调整其vruntime以补偿，这会影响进程在运行队列中的平均负载贡献。
4.  当进程最终被调度运行时，更新与该进程相关的统计信息，比如其累积的等待时间、最近一次的运行时间等。
5.  根据调度器特定的算法和因子，计算当前时间段内该进程的平均负载贡献（load average contribution）。

具体的计算方法可能会受到内核版本和CFS算法实现的影响，而调度器可能会使用一些指数衰减或移动平均的技术来平滑地计算平均负载。
总之，一个普通进程如果在就绪队列中等待了很长时间，CFS会尽可能地补偿它的等待时间，使其得到较高的调度优先级，并在计算平均负载时考虑这种补偿。这有助于保持调度的公平性并优化进程响应时间。