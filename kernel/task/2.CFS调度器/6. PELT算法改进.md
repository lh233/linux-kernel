自从Linux 3.8加入内核之后，各路黑客对PELT算法进行充分的测试同时发现一些问题，并纷纷提出改进的方法。本文介绍Linux 4.0内核的PELT计算方法，但是在Linux 4.0之后又有一些新的改进，例如这里要介绍的PELT算法改进和Linaro开发的WALT（Window Assisted LoadTtracking）算法。

PELT算法中有一个重要的变量runnable_load_avg，用于描述就绪队列基于可运行状态的总衰减累加时间（runnable  time）和权重计算出来的平均负载，但是在Linux 4.0内核代码中，一次更新只有一个调度实体的负载变化，而没有更新cfs_rq所有调度实体的负载变化情况。

如图3.8所示，T1时刻更新调度实体e1的平均负载，e2及其他调度实体的平均负载没有更新，在T2时刻更新调度实体的e2的平均负载，e1及其他调度实体的平均负载没有更新，这样导致整个就绪队列的runnable_load_avg失真。

![image](https://img2024.cnblogs.com/blog/811006/202505/811006-20250512152550130-366986450.png)



Linux 4.3 内核已经对此问题做了优化。在每次更新平均负载时会更新整个cfs_rq的平均负载，详见update_load_avg()函数，为此struct cfs_rq数据结构增加了struct sched_avg成员。 记录平均负载数据结构struct sched_avg也发生了变化。

```
        struct sched_avg {
              u64 last_update_time, load_sum;
              u32 util_sum, period_contrib;
              unsigned long load_avg, util_avg;
        };
```

原来的load_avg_contrib变成了load_avg，它是计算调度实体基于可运行时间（runnable time）的平均负载，并且考虑CPU频率因素。util_avg是计算调度实体基于执行时间内（running time）的平均负载。对于就绪队列来说，上述两个成员都包括可运行时间和阻塞时间。另外在计算平均负载时需要考虑CPU频率的因素。